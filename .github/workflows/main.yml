name: Build & Release

on: push

# 1. If we push to master with a tag, we will trigger workflow twice, use [concurrency] to prevent this
# 2. If last workflow is still running, we push again, we will cancel the previous workflow
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  FLUTTER_VERSION: '3.3.1'

jobs:
  Build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: android
            os: ubuntu-latest
            flutter_version: ${{ ENV.FLUTTER_VERSION }}
            artifact_name: release-apk
            artifact_path: build/app/outputs/apk/release/*.apk
          - target: ios
            os: macos-latest
            flutter_version: ${{ ENV.FLUTTER_VERSION }}
            artifact_name: release-ios
            artifact_path: build/**/*.ipa
            cache_key: ios-pods-${{ hashFiles('.github/workflows/main.yml') }}
            cache_path: ios/Pods
            cache_restore_keys: macos-pods-
          - target: macos
            os: macos-latest
            flutter_version: ${{ ENV.FLUTTER_VERSION }}
            artifact_name: release-mac
            artifact_path: build/macos/*.zip
            cache_key: (macos-pods-${{ hashFiles('.github/workflows/main.yml') }})
            cache_path: macos/Pods
            cache_restore_keys: macos-pods-
          - target: windows
            os: windows-latest
            flutter_version: ${{ ENV.FLUTTER_VERSION }}
            artifact_name: release-windows
            artifact_path: build/windows/*.zip
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          submodules: 'recursive'
      - name: Cache Pods (build ios)
        uses: actions/cache@v3
        with:
          key: ${{ ${{ matrix.cache_key }} }}
          path: ${{ matrix.cache_path }}
          restore-keys: ${{ matrix.cache_restore_keys }}
